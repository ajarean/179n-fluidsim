// #pragma kernel Integrate // Use the force of each particle to move particle
// #pragma kernel ComputeForces // Compute forces for each particle
// #pragma kernel ComputeDensityPressure // Compute density/pressure for each particle

// struct Particle {
//     float pressure;
//     float density;
//     float3 currentForce;
//     float3 velocity;
//     float3 position;
// };

// RWStructuredBuffer<Particle> _particles;

// // Variable Declarations 

// float particleMass;
// float viscosity;
// float gasConstant;
// float restDensity;
// float boundDamping;
// float radius;
// float radius2;
// float radius3;
// float radius4;
// float radius5;
// float pi;
// int particleLength;
// float timestep;
// float3 boxSize;
// float3 spherePos;
// float sphereRadius;


// [numthreads(100,1,1)]
// void Integrate (uint3 id: SV_DISPATCHTHREADID) {

//     float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce/particleMass)*timestep);
//     _particles[id.x].position += vel * timestep;

//     float3 topRight = boxSize/2;
//     float3 bottomLeft = -boxSize/2;

//     // Min Boundary Enforcements
//     if (_particles[id.x].position.x - radius < bottomLeft.x) {
//         vel.x *= boundDamping;
//         _particles[id.x].position.x = bottomLeft.x + radius;
//     }
//     if (_particles[id.x].position.y - radius < bottomLeft.y) {
//        vel.y *= boundDamping;
//         _particles[id.x].position.y = bottomLeft.y + radius;
//     }
//     if (_particles[id.x].position.z - radius < bottomLeft.z) {
//        vel.z *= boundDamping;
//         _particles[id.x].position.z = bottomLeft.z + radius;
//     }

//     // Max Boundary Enforcements
//     if (_particles[id.x].position.x + radius > topRight.x) {
//         vel.x *= boundDamping;
//         _particles[id.x].position.x = topRight.x - radius;
//     }
//     if (_particles[id.x].position.y + radius > topRight.y) {
//        vel.y *= boundDamping;
//         _particles[id.x].position.y = topRight.y - radius;
//     }
//     if (_particles[id.x].position.z + radius > topRight.z) {
//        vel.z *= boundDamping;
//         _particles[id.x].position.z = topRight.z - radius;
//     }

//     if (distance(_particles[id.x].position, spherePos) + radius < sphereRadius) {
//         vel *= boundDamping;
//     }

//     _particles[id.x].velocity = vel;

// }


// float StdKernel (float distanceSquared) {
//     float x = 1.0f - distanceSquared / radius2;
//     return 315.f/ (64.f * pi * radius3) * x * x * x;
// }

// [numthreads(100,1,1)]
// void ComputeDensityPressure (uint3 id: SV_DISPATCHTHREADID) {

//     float3 origin = _particles[id.x].position;
//     float sum = 0;

//     for (int i = 0; i < particleLength; i++) {

//         float3 diff = origin - _particles[i].position;
//         float distanceSquared = dot(diff, diff);

//         if (radius2*0.004 > distanceSquared*0.004) {

//             sum += StdKernel(distanceSquared * 0.004); // Apply smoothing kernel

//         }

//     }

//     _particles[id.x].density = sum * particleMass + 0.000001f;
//     _particles[id.x].pressure = gasConstant * (_particles[id.x].density - restDensity);

// }

// // Smoothing Functions for Compute Forces
// float SpikyKernelFirstDerivative (float distance) {
//     float x = 1.0f - distance/radius;
//     return -45.f/(pi*radius4)*x*x;
// }

// float SpikyKernelSecondDerivative (float distance) {
//     float x = 1.0f - distance/radius;
//     return 90.f / (pi*radius5)*x;
// }

// float3 SpikyKernelGradient (float distance, float3 direction) {
//     return SpikyKernelFirstDerivative(distance)*direction;
// }

// [numthreads(100,1,1)]
// void ComputeForces (uint3 id : SV_DISPATCHTHREADID) {

//     float3 origin = _particles[id.x].position;
//     float density2 = _particles[id.x].density * _particles[id.x].density;
//     float mass2 = particleMass * particleMass;
//     float3 pressure = float3(0,0,0); // To be calculated
//     float3 visc = float3(0,0,0); // To be calculated 
    
//     for (int i = 0; i < particleLength; i++) {

//         if (origin.x == _particles[i].position.x && origin.y == _particles[i].position.y && origin.z == _particles[i].position.z) {
//             continue;
//         }

//         float dist = distance(_particles[i].position, origin);
//         if (dist < radius * 2) {
//             float3 pressureGradientDirection = normalize(_particles[id.x].position - _particles[i].position);
            
//             float3 _pressureContribution = mass2 * SpikyKernelGradient(dist, pressureGradientDirection);
//             _pressureContribution *= (_particles[id.x].pressure / density2 + _particles[i].pressure / (_particles[i].density * _particles[i].density));

//             float3 _viscosityContribution = viscosity * mass2 * (_particles[i].velocity - _particles[id.x].velocity)/_particles[i].density;
//             _viscosityContribution *= SpikyKernelSecondDerivative(dist);

//             pressure += _pressureContribution;
//             visc += _viscosityContribution; 
//         }

//     }

//     _particles[id.x].currentForce = float3(0,-9.81*particleMass,0) - pressure + visc;

//     float3 colDir = _particles[id.x].position - spherePos;
//     if (length(colDir) < sphereRadius) {
//         _particles[id.x].currentForce += colDir * 300;
//     }
// }


#pragma kernel Integrate
#pragma kernel ComputeDensityPrssure
#pragma kernel ComputeForces

struct Particle
{
    float3 position;
    float3 velocity;
    float3 currentForce;
    float pressure;
    float density;
};

// Particle buffer
RWStructuredBuffer<Particle> particlesBuffer;

float particleMass;
float radius;
float radius2;
float radius3;
float radius4;
float radius5;
float pi;
float gasConstant;
float viscosity;
float restDensity;
float boundDamping;
float timestep;
float3 boxSize;
float3 spherePos;
float sphereRadius;
float collisionForceMod = 300.0f;


[numthreads(256,1,1)]
void Integrate (uint3 id : SV_DispatchThreadID){
    Particle* p = &particlesBuffer[id.x];
   float3 vel = p.velocity + ((p.currentForce/particleMass)* timestep);
    p.position += vel * timestep;


    float3 topRight = boxSize/2;
    float3 bottomLeft = -boxSize/2;

    if(p.position.x - radius < bottomLeft.x){
      vel.x *= boundDamping;
      p.position.x = bottomLeft.x + radius;
    }
    if(p.position.y - radius < bottomLeft.y){
      vel.y *= boundDamping;
      p.position.y = bottomLeft.y + radius;
    }
    if(p.position.z - radius < bottomLeft.z){
      vel.z *= boundDamping;
      p.position.z = bottomLeft.z + radius;
    }
    if(p.position.x + radius > topRight.x){
      vel.x *= boundDamping;
      p.position.x = topRight.x - radius;
    }
    if(p.position.y + radius > topRight.y){
      vel.y *= boundDamping;
      p.position.y = topRight.y - radius;
    }
    if(p.position.z + radius > topRight.z){
      vel.z *= boundDamping;
      p.position.z = topRight.z - radius;
    }
    if(distance(p.position, spherePos) + radius < sphereRadius){
      vel *= boundDamping;
    }
    p.velocity = vel;
}

float StdKernel (float distanceSqrd) {
  float x = 1.0f - distanceSqrd / radius2;
  return (315.0f / (64.0f * pi * radius3)) * x * x * x;
}

[numthreads(256,1,1)]
void ComputeDensityPrssure (uint3 id : SV_DispatchThreadID){
    Particle* p = &particlesBuffer[id.x];
    float3 origin = p.position;
    float density = 0.0f;
    for (int i = 0; i < particlesBuffer.Length; i++){
        Particle* other = &particlesBuffer[i];
        float3 diff = origin - other.position;
        float distanceSqrd = dot(diff, diff);
        if (distanceSqrd*0.004 < radius2*0.004 && distanceSqrd > 0.0f){
            density += particleMass* StdKernel(distanceSqrd*0.004);
        }
    }
    p.density = density + 0.00001f;
    p.pressure = gasConstant * (p.density - restDensity);
}

float SpikyKernelFirstDerivative (float distance) {
  float x =1.0f - distance/radius;
  return (-45.0f / (pi * radius4)) * x * x;
}
float SpikyKernelSecondDerivative (float distance) {
  float x =1.0f - distance/radius;
  return (90.0f / (pi * radius5)) * x;
}
float SpikyKernelGradient (float distance, float3 direction){
  return SpikyKernelFirstDerivative(distance) * direction;
}

[numthreads(256,1,1)]
void ComputeForces (uint3 id : SV_DispatchThreadID){
    Particle* p = &particlesBuffer[id.x];

    float3 origin = p.position;
    float density2 = p.density * p.density;
    float mass2 = particleMass * particleMass;
    float3 pressure = float3(0,0,0); //calc'd in function
    float3 visc = float3(0,0,0);

    for (int i = 0; i < particlesBuffer.Length; i++){ // implement neighbor search later
        Particle* other = &particlesBuffer[i];
        if (origin == other.position) continue; //dont check same point

        float dist  = distance(p.position, other.position);
        if(dist < radius*2){
          float3 pressureGradDir = normalize(p.position - other.position);
          float3 _pressureContrib = mass2 * SpikyKernelGradient(dist, pressureGradDir);
          _pressureContrib *= (p.pressure / density2  + other.pressure / (other.density * other.density));
          pressure += _pressureContrib;

          float3 _viscContrib = mass2 * viscosity * (other.velocity - p.velocity)/(p.density+0.00001f);
          _viscContrib *= SpikyKernelSecondDerivative(dist);
          visc += _viscContrib;

        }
    }
    float3 grav = float3(0, -9.81 * particleMass, 0);
    p.currentForce = grav - pressure + visc;
    float3 colDir = p.position - spherePos;
    if (length(colDir) < sphereRadius + radius) {
       p.currentForce += colDir * collisionForceMod;
    }
}